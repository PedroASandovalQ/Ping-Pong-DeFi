"use strict";
/**
 * @file Comet
 * @desc These methods facilitate interactions with Compound III.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.getBaseAssetName = exports.getSupportedCollaterals = exports.getSupportedDeployments = exports.getAssetInfoBySymbol = exports.getAssetInfoByAddress = exports.getAssetInfo = exports.collateralBalanceOf = exports.borrowBalanceOf = exports.getPrice = exports.buyCollateral = exports.quoteCollateral = exports.isLiquidatable = exports.isBorrowCollateralized = exports.targetReserves = exports.getReserves = exports.absorb = exports.getUtilization = exports.getBorrowRate = exports.getSupplyRate = exports.withdrawFrom = exports.withdrawTo = exports.withdraw = exports.transfer = exports.createAllowSignature = exports.allowBySig = exports.allow = exports.supply = void 0;
var ethers_1 = require("ethers");
var eth = require("./eth");
var helpers_1 = require("./helpers");
var EIP712_1 = require("./EIP712");
var constants_1 = require("./constants");
var address = constants_1.cometConstants.address, decimals = constants_1.cometConstants.decimals, collaterals = constants_1.cometConstants.collaterals, base = constants_1.cometConstants.base;
function isValidEthereumAddress(_address) {
    var result = true;
    if (typeof _address !== 'string' ||
        _address.length !== 42 ||
        !_address.startsWith('0x')) {
        result = false;
    }
    return result;
}
function checkValidCometProvider(comet) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, helpers_1.netId(comet)];
                case 1:
                    _a.sent();
                    if (typeof comet._invalidProvider === 'string') {
                        throw Error(comet._invalidProvider);
                    }
                    return [2 /*return*/];
            }
        });
    });
}
/**
 * Supplies the user's Ethereum asset to Compound Comet.
 *
 * @param {string} from A string of the address that the supplied asset is
 *     supplied from. This allows approved account managers to supply on behalf
 *     of an account that has already approved their ERC-20 asset to be
 *     transferred to the Comet contract. To supply on behalf of the sender,
 *     this should be set to the sender's address.
 * @param {string} dst A string of the address that the supplied asset is
 *     credited to within Comet. To supply to the sender's account, this should
 *     be set to the sender's address.
 * @param {string} asset A string of the name of the asset to supply.
 * @param {number | string | BigNumber} amount A string, number, or BigNumber
 *     object of the amount of an asset to supply. Use the `mantissa` boolean in
 *     the `options` parameter to indicate if this value is scaled up (so there
 *     are no decimals) or in its natural scale.
 * @param {boolean} noApprove Explicitly prevent this method from attempting an
 *     ERC-20 `approve` transaction prior to sending the `supply` transaction.
 * @param {CallOptions} [options] Call options and Ethers.js overrides for the
 *     transaction. A passed `gasLimit` will be used in both the `approve` (if
 *     not supressed) and `supply` transactions.
 *
 * @returns {object} Returns an Ethers.js transaction object of the supply
 *     transaction.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * // Ethers.js overrides are an optional last parameter
 * // const trxOptions = { gasLimit: 250000, mantissa: false };
 *
 * (async function() {
 *
 *   const me = '0xSenderAddress'; // can be compound._provider.address
 *
 *   console.log('Supplying ETH to Compound Comet...');
 *   const trx = await comet.supply(
 *     me, // supplied asset comes from this account
 *     me, // supplied asset is credited to this account's balance
 *     Compound.WBTC,
 *     3
 *   );
 *   console.log('Ethers.js transaction object', trx);
 *
 * })().catch(console.error);
 * ```
 */
function supply(from, dst, asset, amount, noApprove, options) {
    if (noApprove === void 0) { noApprove = false; }
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var errorPrefix, cometAddress, assetAddress, userAddress, allowance, notEnough, parameters;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    errorPrefix = 'Compound Comet [supply] | ';
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    try {
                        assetAddress = address[this._cometDeploymentName][asset].contract;
                    }
                    catch (e) { }
                    if (!isValidEthereumAddress(from)) {
                        throw Error(errorPrefix + 'Argument `from` is not a string or is an invalid address.');
                    }
                    if (!isValidEthereumAddress(dst)) {
                        throw Error(errorPrefix + 'Argument `dst` is not a string or is an invalid address.');
                    }
                    if (!assetAddress || !collaterals[this._cometDeploymentName].includes(asset)) {
                        throw Error(errorPrefix + 'Argument `asset` cannot be supplied.');
                    }
                    if (typeof amount !== 'number' &&
                        typeof amount !== 'string' &&
                        !ethers_1.ethers.BigNumber.isBigNumber(amount)) {
                        throw Error(errorPrefix + 'Argument `amount` must be a string, number, or BigNumber.');
                    }
                    if (!options.mantissa) {
                        amount = +amount;
                        amount = amount * Math.pow(10, decimals[this._cometDeploymentName][asset]);
                    }
                    amount = ethers_1.ethers.BigNumber.from(amount.toString());
                    options.abi = constants_1.abi.Erc20;
                    options._compoundProvider = this._provider;
                    if (!(noApprove !== true)) return [3 /*break*/, 6];
                    userAddress = this._provider.address;
                    if (!(!userAddress && this._provider.getAddress)) return [3 /*break*/, 3];
                    return [4 /*yield*/, this._provider.getAddress()];
                case 2:
                    userAddress = _a.sent();
                    _a.label = 3;
                case 3: return [4 /*yield*/, eth.read(assetAddress, 'allowance', [userAddress, cometAddress], options)];
                case 4:
                    allowance = _a.sent();
                    notEnough = allowance.lt(amount);
                    if (!notEnough) return [3 /*break*/, 6];
                    // ERC-20 approve transaction
                    return [4 /*yield*/, eth.trx(assetAddress, 'approve', [cometAddress, amount], options)];
                case 5:
                    // ERC-20 approve transaction
                    _a.sent();
                    _a.label = 6;
                case 6:
                    options.abi = constants_1.abi.Comet;
                    parameters = [from, dst, assetAddress, amount];
                    return [2 /*return*/, eth.trx(cometAddress, 'supplyFrom', parameters, options)];
            }
        });
    });
}
exports.supply = supply;
/**
 * Allows or disallows an address to withdraw or transfer on behalf of the
 *     Sender's address.
 *
 * @param {string} manager The address of the manager.
 * @param {boolean} isAllowed True to add the manager and false to remove the
 *     manager.
 * @param {CallOptions} [options] Call options and Ethers.js overrides for the
 *     transaction.
 *
 * @returns {object} Returns an Ethers.js transaction object of the allow
 *     transaction.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const address = '0xManagerAddressHere';
 *   const trx = await comet.allow(address, true);
 *   console.log('Ethers.js transaction object', trx);
 * })().catch(console.error);
 * ```
 */
function allow(manager, isAllowed, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var errorPrefix, cometAddress, parameters, trxOptions;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    errorPrefix = 'Compound Comet [allow] | ';
                    if (!isValidEthereumAddress(manager)) {
                        throw Error(errorPrefix + 'Argument `manager` is not a string or is an invalid address.');
                    }
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    parameters = [manager, !!isAllowed];
                    trxOptions = __assign({ _compoundProvider: this._provider, abi: constants_1.abi.Comet }, options);
                    return [2 /*return*/, eth.trx(cometAddress, 'allow', parameters, trxOptions)];
            }
        });
    });
}
exports.allow = allow;
/**
 * Enable or disable a Comet account manager using an EIP-712 signature.
 *
 * @param {string} owner The address of the account that is changing a manager.
 * @param {string} manager The address of the manager of the account.
 * @param {boolean} isAllowed Pass true to enable a manager, false to disable.
 * @param {number} nonce The contract state required to match the signature.
 *     This can be retrieved from the contract's public nonces mapping.
 * @param {number} expiry The time at which to expire the signature. A block
 *     timestamp as seconds since the unix epoch.
 * @param {object} signature An object that contains the v, r, and, s values of
 *     an EIP-712 signature.
 * @param {CallOptions} [options] Options to set for `eth_call`, optional ABI
 *     (as JSON object), and Ethers.js method overrides. The ABI can be a string
 *     of the single intended method, an array of many methods, or a JSON object
 *     of the ABI generated by a Solidity compiler.
 *
 * @returns {object} Returns an Ethers.js transaction object of the allow
 *     transaction.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function() {
 *   const allowTx = await comet.allowBySig(
 *     '0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa',
 *     '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     true,
 *     42,
 *     9999999999,
 *     {
 *       v: '0x1b',
 *       r: '0x130dbca2fafa07424c033b4479687cc1deeb65f08809e3ab397988cc4c6f2e78',
 *       s: '0x1debeb8250262f23906b1177161f0c7c9aa3641e8bff5b6f5c88a6bb78d5d8cd'
 *     }
 *   );
 *   console.log('Ethers.js transaction object', allowTx);
 * })().catch(console.error);
 * ```
 */
function allowBySig(owner, manager, isAllowed, nonce, expiry, signature, options) {
    if (signature === void 0) { signature = { v: '', r: '', s: '' }; }
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var errorPrefix, cometAddress, trxOptions, v, r, s, parameters, method;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    errorPrefix = 'Compound [allowBySig] | ';
                    if (typeof owner !== 'string') {
                        throw Error(errorPrefix + 'Argument `owner` must be a string.');
                    }
                    try {
                        owner = helpers_1.toChecksumAddress(owner);
                    }
                    catch (e) {
                        throw Error(errorPrefix + 'Argument `owner` must be a valid Ethereum address.');
                    }
                    if (typeof manager !== 'string') {
                        throw Error(errorPrefix + 'Argument `manager` must be a string.');
                    }
                    try {
                        manager = helpers_1.toChecksumAddress(manager);
                    }
                    catch (e) {
                        throw Error(errorPrefix + 'Argument `manager` must be a valid Ethereum address.');
                    }
                    if (typeof nonce !== 'number') {
                        throw Error(errorPrefix + 'Argument `nonce` must be an integer.');
                    }
                    if (typeof expiry !== 'number') {
                        throw Error(errorPrefix + 'Argument `expiry` must be an integer.');
                    }
                    if (!Object.isExtensible(signature) ||
                        !signature.v ||
                        !signature.r ||
                        !signature.s) {
                        throw Error(errorPrefix + 'Argument `signature` must be an object that ' +
                            'contains the v, r, and s pieces of an EIP-712 signature.');
                    }
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    trxOptions = __assign(__assign({}, options), { _compoundProvider: this._provider, abi: constants_1.abi.Comet });
                    v = signature.v, r = signature.r, s = signature.s;
                    parameters = [owner, manager, isAllowed, nonce, expiry, v, r, s];
                    method = 'allowBySig';
                    return [2 /*return*/, eth.trx(cometAddress, method, parameters, trxOptions)];
            }
        });
    });
}
exports.allowBySig = allowBySig;
/**
 * Create an EIP-712 signature for enabling or disabling a Comet account
 *     manager. Anyone can post it to the blockchain using the `allowBySig`
 *     method, which does have gas costs.
 *
 * @param {string} manager The address of the manager of the account.
 * @param {boolean} isAllowed Pass true to enable a manager, false to disable.
 * @param {number} [expiry] The time at which to expire the signature. A block
 *     timestamp as seconds since the unix epoch. Defaults to `10e9`.
 *
 * @returns {object} Returns an object that contains the `v`, `r`, and `s`
 *     components of an Ethereum signature as hexadecimal strings.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async () => {
 *
 *   const allowSignature = await comet.createAllowSignature(
 *     '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     true
 *   );
 *   console.log('allowSignature', allowSignature);
 *
 * })().catch(console.error);
 * ```
 */
function createAllowSignature(manager, isAllowed, expiry) {
    if (expiry === void 0) { expiry = 10e9; }
    return __awaiter(this, void 0, void 0, function () {
        var errorPrefix, net, provider, cometAddress, chainId, userAddress, owner, nonce, name, version, domain, primaryType, message, types, signer, signature;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    errorPrefix = 'Compound Comet [createAllowSignature] | ';
                    net = this._network;
                    provider = this._provider;
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    chainId = net.id;
                    userAddress = provider.address;
                    if (!(!userAddress && provider.getAddress)) return [3 /*break*/, 3];
                    return [4 /*yield*/, provider.getAddress()];
                case 2:
                    userAddress = _a.sent();
                    _a.label = 3;
                case 3:
                    owner = userAddress;
                    if (typeof manager !== 'string') {
                        throw Error(errorPrefix + 'Argument `manager` must be a string.');
                    }
                    try {
                        manager = helpers_1.toChecksumAddress(manager);
                    }
                    catch (e) {
                        throw Error(errorPrefix + 'Argument `manager` must be a valid Ethereum address.');
                    }
                    return [4 /*yield*/, eth.read(cometAddress, 'function userNonce(address) returns (uint)', [userAddress], { provider: provider })];
                case 4:
                    nonce = +(_a.sent()).toString();
                    return [4 /*yield*/, eth.read(cometAddress, 'function name() view returns (string memory)', [], { provider: provider })];
                case 5:
                    name = (_a.sent()).toString();
                    return [4 /*yield*/, eth.read(cometAddress, 'function version() view returns (string memory)', [], { provider: provider })];
                case 6:
                    version = (_a.sent()).toString();
                    domain = {
                        name: name,
                        version: version,
                        chainId: chainId,
                        verifyingContract: cometAddress
                    };
                    primaryType = 'Authorization';
                    message = {
                        owner: owner,
                        manager: manager,
                        isAllowed: isAllowed,
                        nonce: nonce,
                        expiry: expiry
                    };
                    types = {
                        EIP712Domain: [
                            { name: 'name', type: 'string' },
                            { name: 'version', type: 'string' },
                            { name: 'chainId', type: 'uint256' },
                            { name: 'verifyingContract', type: 'address' },
                        ],
                        Authorization: [
                            { name: 'owner', type: 'address' },
                            { name: 'manager', type: 'address' },
                            { name: 'isAllowed', type: 'bool' },
                            { name: 'nonce', type: 'uint256' },
                            { name: 'expiry', type: 'uint256' }
                        ]
                    };
                    signer = provider.getSigner ? provider.getSigner() : provider;
                    return [4 /*yield*/, EIP712_1.sign(domain, primaryType, message, types, signer)];
                case 7:
                    signature = _a.sent();
                    return [2 /*return*/, signature];
            }
        });
    });
}
exports.createAllowSignature = createAllowSignature;
/**
 * Transfers an asset to another account within Compound Comet.
 *
 * @param {string | boolean} src The source account address in the transfer. If
 *     the transfer is on behalf of the sender instead of a manager, `true` can
 *     be passed instead of an address as a string.
 * @param {string} dst The desination account address in the transfer.
 * @param {string} asset A string of the name of the asset to transfer.
 * @param {number | string | BigNumber} amount A string, number, or BigNumber
 *     object of the amount of an asset to transfer. Use the `mantissa` boolean
 *     in the `options` parameter to indicate if this value is scaled up (so
 *     there are no decimals) or in its natural scale.
 * @param {CallOptions} [options] Call options and Ethers.js overrides for the
 *     transaction.
 *
 * @returns {object} Returns an Ethers.js transaction object of the transfer
 *     transaction.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * // Ethers.js overrides are an optional last parameter
 * // const trxOptions = { gasLimit: 250000 };
 *
 * (async function() {
 *
 *   console.log('Transferring WETH in Compound Comet...');
 *   const trx = await comet.transfer(
 *     true, // on behalf of the sender
 *     destinationAddress,
 *     Compound.WETH,
 *     '10000000',
 *     trxOptions
 *   );
 *   console.log('Ethers.js transaction object', trx);
 *
 * })().catch(console.error);
 * ```
 */
function transfer(src, dst, asset, amount, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var errorPrefix, cometAddress, assetAddress, parameters;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    errorPrefix = 'Compound Comet [transfer] | ';
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    try {
                        assetAddress = address[this._cometDeploymentName][asset].contract;
                    }
                    catch (e) { }
                    if (!src ||
                        (src !== true &&
                            (typeof src !== 'string' ||
                                src.length !== 42 ||
                                !src.startsWith('0x')))) {
                        throw Error(errorPrefix + 'Argument `src` is invalid.');
                    }
                    if (!isValidEthereumAddress(dst)) {
                        throw Error(errorPrefix + 'Argument `dst` is not a string or is an invalid address.');
                    }
                    if (!assetAddress || !collaterals[this._cometDeploymentName].includes(asset)) {
                        throw Error(errorPrefix + 'Argument `asset` cannot be transferred.');
                    }
                    if (typeof amount !== 'number' &&
                        typeof amount !== 'string' &&
                        !ethers_1.ethers.BigNumber.isBigNumber(amount)) {
                        throw Error(errorPrefix + 'Argument `amount` must be a string, number, or BigNumber.');
                    }
                    if (!options.mantissa) {
                        amount = +amount;
                        amount = amount * Math.pow(10, decimals[this._cometDeploymentName][asset]);
                    }
                    amount = ethers_1.ethers.BigNumber.from(amount.toString());
                    if (!(src === true)) return [3 /*break*/, 3];
                    return [4 /*yield*/, this._provider.getAddress()];
                case 2:
                    src = _a.sent();
                    _a.label = 3;
                case 3:
                    options._compoundProvider = this._provider;
                    options.abi = constants_1.abi.Comet;
                    parameters = [src, dst, assetAddress, amount];
                    return [2 /*return*/, eth.trx(cometAddress, 'transferAssetFrom', parameters, options)];
            }
        });
    });
}
exports.transfer = transfer;
/**
 * Withdraws an asset from Compound Comet from the sender's account to itself.
 *
 * @param {string} asset A string of the name of the asset to withdraw.
 * @param {number | string | BigNumber} amount A string, number, or BigNumber
 *     object of the amount of an asset to withdraw. Use the `mantissa` boolean
 *     in the `options` parameter to indicate if this value is scaled up (so
 *     there are no decimals) or in its natural scale.
 * @param {CallOptions} [options] Call options and Ethers.js overrides for the
 *     transaction.
 *
 * @returns {object} Returns an Ethers.js transaction object of the withdraw
 *     transaction.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * // Ethers.js overrides are an optional last parameter
 * // const trxOptions = { gasLimit: 250000 };
 *
 * (async function() {
 *
 *   console.log('Withdrawing DAI from my account...');
 *   const trx = await comet.withdraw(
 *     Compound.DAI,
 *     10,
 *     trxOptions
 *   );
 *   console.log('Ethers.js transaction object', trx);
 *
 * })().catch(console.error);
 * ```
 */
function withdraw(asset, amount, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var src, dst;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, this._provider.getAddress()];
                case 1:
                    src = _a.sent();
                    dst = src;
                    return [2 /*return*/, _withdraw('withdraw', src, dst, asset, amount, options, this)];
            }
        });
    });
}
exports.withdraw = withdraw;
/**
 * Withdraws an asset from Compound Comet from the sender's account to another.
 *
 * @param {string} dst The desination account address in the withdrawal.
 * @param {string} asset A string of the name of the asset to withdraw.
 * @param {number | string | BigNumber} amount A string, number, or BigNumber
 *     object of the amount of an asset to withdraw. Use the `mantissa` boolean
 *     in the `options` parameter to indicate if this value is scaled up (so
 *     there are no decimals) or in its natural scale.
 * @param {CallOptions} [options] Call options and Ethers.js overrides for the
 *     transaction.
 *
 * @returns {object} Returns an Ethers.js transaction object of the withdraw
 *     transaction.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * // Ethers.js overrides are an optional last parameter
 * // const trxOptions = { gasLimit: 250000 };
 *
 * (async function() {
 *
 *   console.log('Withdrawing DAI from my account to dst account...');
 *   const trx = await comet.withdrawTo(
 *     dst, // destination, the address that the withdrawn asset is sent to
 *     Compound.DAI,
 *     10,
 *     trxOptions
 *   );
 *   console.log('Ethers.js transaction object', trx);
 *
 * })().catch(console.error);
 * ```
 */
function withdrawTo(dst, asset, amount, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var src;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, this._provider.getAddress()];
                case 1:
                    src = _a.sent();
                    return [2 /*return*/, _withdraw('withdrawTo', src, dst, asset, amount, options, this)];
            }
        });
    });
}
exports.withdrawTo = withdrawTo;
/**
 * Withdraws an asset from Compound Comet from one account to another. The
 *     caller must be an allowed manager for the source account.
 *
 * @param {string} src The source account address in the withdrawal. The sender
 *     must be an allowed manager for the source account.
 * @param {string} dst The desination account address in the withdrawal.
 * @param {string} asset A string of the name of the asset to withdraw.
 * @param {number | string | BigNumber} amount A string, number, or BigNumber
 *     object of the amount of an asset to withdraw. Use the `mantissa` boolean
 *     in the `options` parameter to indicate if this value is scaled up (so
 *     there are no decimals) or in its natural scale.
 * @param {CallOptions} [options] Call options and Ethers.js overrides for the
 *     transaction.
 *
 * @returns {object} Returns an Ethers.js transaction object of the withdraw
 *     transaction.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * // Ethers.js overrides are an optional last parameter
 * // const trxOptions = { gasLimit: 250000 };
 *
 * (async function() {
 *
 *   console.log('Withdrawing DAI from src account to dst account...');
 *   const trx = await comet.withdrawFrom(
 *     src, // source address, sender must be an allowed manager for the address
 *     dst, // destination, the address that the withdrawn asset is sent to
 *     Compound.DAI,
 *     10,
 *     trxOptions
 *   );
 *   console.log('Ethers.js transaction object', trx);
 *
 * })().catch(console.error);
 * ```
 */
function withdrawFrom(src, dst, asset, amount, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, _withdraw('withdrawFrom', src, dst, asset, amount, options, this)];
        });
    });
}
exports.withdrawFrom = withdrawFrom;
function _withdraw(overloadName, src, dst, asset, amount, options, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
_cometInstance) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var errorPrefix, cometAddress, assetAddress, parameters;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(_cometInstance)];
                case 1:
                    _a.sent();
                    errorPrefix = "Compound Comet [" + overloadName + "] | ";
                    cometAddress = address[_cometInstance._cometDeploymentName][constants_1.constants.Comet];
                    try {
                        assetAddress = address[_cometInstance._cometDeploymentName][asset].contract;
                    }
                    catch (e) { }
                    if (!isValidEthereumAddress(src)) {
                        throw Error(errorPrefix + 'Argument `src` is not a string or is an invalid address.');
                    }
                    if (!isValidEthereumAddress(dst)) {
                        throw Error(errorPrefix + 'Argument `dst` is not a string or is an invalid address.');
                    }
                    if (!assetAddress || !collaterals[_cometInstance._cometDeploymentName].includes(asset)) {
                        throw Error(errorPrefix + 'Argument `asset` cannot be withdrawn.');
                    }
                    if (typeof amount !== 'number' &&
                        typeof amount !== 'string' &&
                        !ethers_1.ethers.BigNumber.isBigNumber(amount)) {
                        throw Error(errorPrefix + 'Argument `amount` must be a string, number, or BigNumber.');
                    }
                    if (!options.mantissa) {
                        amount = +amount;
                        amount = amount * Math.pow(10, decimals[_cometInstance._cometDeploymentName][asset]);
                    }
                    amount = ethers_1.ethers.BigNumber.from(amount.toString());
                    options._compoundProvider = _cometInstance._provider;
                    options.abi = constants_1.abi.Comet;
                    parameters = [src, dst, assetAddress, amount];
                    return [2 /*return*/, eth.trx(cometAddress, 'withdrawFrom', parameters, options)];
            }
        });
    });
}
/**
 * Gets the supply rate. This method returns the current supply rate as the
 *     decimal representation of a percentage scaled up by 10 ^ 18.
 *
 * @param {string | number | BigNumber} [utilization] A number representing the
 *     utilization rate in which to get the corresponding supply rate. The
 *     current utilization rate can be fetched by using `Compound.comet.getUtilization()`.
 *
 * @returns {string} Returns a string of the numeric value of the supply rate.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const supplyRate = await comet.getSupplyRate();
 *   console.log('Supply Rate', supplyRate);
 * })().catch(console.error);
 * ```
 */
function getSupplyRate(utilization) {
    return __awaiter(this, void 0, void 0, function () {
        var cometAddress, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    parameters = [utilization.toString()];
                    trxOptions = {
                        _compoundProvider: this._provider.provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'getSupplyRate', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result.toString()];
            }
        });
    });
}
exports.getSupplyRate = getSupplyRate;
/**
 * Gets the borrow rate. This method returns the current borrow rate as the
 *     decimal representation of a percentage scaled up by 10 ^ 18.
 *
 * @param {string | number | BigNumber} [utilization] A number representing the
 *     utilization rate in which to get the corresponding supply rate. The
 *     current utilization rate can be fetched by using `Compound.comet.getUtilization()`.
 *
 * @returns {string} Returns a string of the numeric value of the borrow rate.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const borrowRate = await comet.getBorrowRate();
 *   console.log('Borrow Rate', borrowRate);
 * })().catch(console.error);
 * ```
 */
function getBorrowRate(utilization) {
    return __awaiter(this, void 0, void 0, function () {
        var cometAddress, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    parameters = [utilization.toString()];
                    trxOptions = {
                        _compoundProvider: this._provider.provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'getBorrowRate', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result.toString()];
            }
        });
    });
}
exports.getBorrowRate = getBorrowRate;
/**
 * Gets the utilization rate.
 *
 * @returns {string} Returns the current protocol utilization as a percentage as
 *     a decimal, represented by an unsigned integer, scaled up by 10 ^ 18.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const utilization = await comet.getUtilization();
 *   console.log('Utilization', utilization);
 * })().catch(console.error);
 * ```
 */
function getUtilization() {
    return __awaiter(this, void 0, void 0, function () {
        var cometAddress, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    parameters = [];
                    trxOptions = {
                        _compoundProvider: this._provider.provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'getUtilization', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result.toString()];
            }
        });
    });
}
exports.getUtilization = getUtilization;
/**
 * This method triggers the liquidation of one or many underwater accounts.
 *
 * @param {string} absorber The account that is issued liquidator points during
 *     successful execution.
 * @param {string | string[]} accounts A string of one or an array of many
 *     addresses of underwater accounts.
 * @param {CallOptions} [options] Call options and Ethers.js overrides for the
 *     transaction.
 *
 * @returns {object} Returns an Ethers.js transaction object of the absorb
 *     transaction.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const addresses = [
 *     '0xUnderwaterAccountAddress1',
 *   ];
 *   const trx = await comet.absorb(addresses);
 *   console.log('Ethers.js transaction object', trx);
 * })().catch(console.error);
 * ```
 */
function absorb(absorber, accounts, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var errorPrefix, invalid, i, cometAddress, parameters, trxOptions;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    errorPrefix = 'Compound Comet [absorb] | ';
                    if (!isValidEthereumAddress(absorber)) {
                        throw Error(errorPrefix + 'Argument `absorber` is not a string or is an invalid address.');
                    }
                    if (!Array.isArray(accounts)) {
                        invalid = true;
                    }
                    else {
                        for (i = 0; i < accounts.length; i++) {
                            if (!isValidEthereumAddress(accounts[i])) {
                                invalid = true;
                                break;
                            }
                        }
                    }
                    if (invalid) {
                        throw Error(errorPrefix + 'Argument `accounts` array contains an invalid address or is otherwise invalid.');
                    }
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    parameters = [absorber, accounts];
                    trxOptions = __assign({ _compoundProvider: this._provider, abi: constants_1.abi.Comet }, options);
                    return [2 /*return*/, eth.trx(cometAddress, 'absorb', parameters, trxOptions)];
            }
        });
    });
}
exports.absorb = absorb;
/**
 * Gets the Comet protocol reserves for the base asset as an integer.
 *
 * @returns {string} Returns the current protocol reserves in in the base asset
 *     as an unsigned integer, scaled up by 10 to the "decimals" integer in the
 *     base asset's contract.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const reserves = await comet.getReserves();
 *   console.log('Reserves', reserves);
 * })().catch(console.error);
 * ```
 */
function getReserves() {
    return __awaiter(this, void 0, void 0, function () {
        var cometAddress, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    parameters = [];
                    trxOptions = {
                        _compoundProvider: this._provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'getReserves', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result.toString()];
            }
        });
    });
}
exports.getReserves = getReserves;
/**
 * Gets the Comet protocol target reserves.
 *
 * @returns {string} Returns the protocol target reserves in the base asset as
 *     an unsigned integer, scaled up by 10 to the "decimals" integer in the
 *     base asset's contract.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const target = await comet.targetReserves();
 *   console.log('Target Reserves', target);
 * })().catch(console.error);
 * ```
 */
function targetReserves() {
    return __awaiter(this, void 0, void 0, function () {
        var cometAddress, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    parameters = [];
                    trxOptions = {
                        _compoundProvider: this._provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'targetReserves', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result.toString()];
            }
        });
    });
}
exports.targetReserves = targetReserves;
/**
 * Gets the collateralization of an account as a boolean.
 *
 * @param {string} account The account address as a string.
 *
 * @returns {boolean} Returns the collateralization of the account as a boolean.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const address = '0xAccountThatBorrows';
 *   const isCollateralized = await comet.isBorrowCollateralized(address);
 *   console.log('Is Collateralized', isCollateralized);
 * })().catch(console.error);
 * ```
 */
function isBorrowCollateralized(account) {
    return __awaiter(this, void 0, void 0, function () {
        var cometAddress, errorPrefix, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    errorPrefix = 'Compound Comet [isBorrowCollateralized] | ';
                    if (!isValidEthereumAddress(account)) {
                        throw Error(errorPrefix + 'Argument `account` is not a string or is an invalid address.');
                    }
                    parameters = [account];
                    trxOptions = {
                        _compoundProvider: this._provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'isBorrowCollateralized', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
exports.isBorrowCollateralized = isBorrowCollateralized;
/**
 * Checks if the passed account is presently liquidatable.
 *
 * @param {string} account The account address as a string.
 *
 * @returns {boolean} Returns the ability to liquidate the account as a boolean.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const address = '0xAccountThatBorrows';
 *   const isLiquidatable = await comet.isLiquidatable(address);
 *   console.log('Is Liquidatable', isLiquidatable);
 * })().catch(console.error);
 * ```
 */
function isLiquidatable(account) {
    return __awaiter(this, void 0, void 0, function () {
        var cometAddress, errorPrefix, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    errorPrefix = 'Compound Comet [isLiquidatable] | ';
                    if (!isValidEthereumAddress(account)) {
                        throw Error(errorPrefix + 'Argument `account` is not a string or is an invalid address.');
                    }
                    parameters = [account];
                    trxOptions = {
                        _compoundProvider: this._provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'isLiquidatable', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
exports.isLiquidatable = isLiquidatable;
/**
 * Gets the price of the asset that is passed to it in USD as an unsigned
 *     integer, scaled up by 10 ^ 8.
 *
 * @param {string} asset A string of the name of the asset.
 * @param {number | string | BigNumber} baseAmount A string, number, or BigNumber
 *     object of the amount of the base asset to get a quote. Use the `mantissa`
 *     boolean in the `options` parameter to indicate if this value is scaled up
 *     (so there are no decimals) or in its natural scale.
 * @param {CallOptions} [options] Call options and Ethers.js overrides for the
 *     transaction.
 *
 * @returns {string} Returns the price of the asset that is passed to it in USD
 *     as an unsigned integer, scaled up by 10 ^ 6.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const price = await comet.quoteCollateral(Compound.UNI, '1000000000');
 *   console.log('Price quote of 1000 base asset of UNI', price);
 * })().catch(console.error);
 * ```
 */
function quoteCollateral(asset, baseAmount, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var deployment, cometAddress, assetAddress, errorPrefix, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    deployment = this._cometDeploymentName;
                    cometAddress = address[deployment][constants_1.constants.Comet];
                    try {
                        assetAddress = address[deployment][asset].contract;
                    }
                    catch (e) { }
                    errorPrefix = 'Compound Comet [quoteCollateral] | ';
                    if (!assetAddress || !collaterals[deployment].includes(asset)) {
                        throw Error(errorPrefix + 'Argument `asset` is not priceable.');
                    }
                    if (typeof baseAmount !== 'number' &&
                        typeof baseAmount !== 'string' &&
                        !ethers_1.ethers.BigNumber.isBigNumber(baseAmount)) {
                        throw Error(errorPrefix + 'Argument `baseAmount` must be a string, number, or BigNumber.');
                    }
                    if (!options.mantissa) {
                        baseAmount = +baseAmount;
                        baseAmount = baseAmount * Math.pow(10, decimals[deployment][getBaseAssetName(deployment)]);
                    }
                    baseAmount = ethers_1.ethers.BigNumber.from(baseAmount.toString());
                    parameters = [assetAddress, baseAmount];
                    trxOptions = {
                        _compoundProvider: this._provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'quoteCollateral', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result.toString()];
            }
        });
    });
}
exports.quoteCollateral = quoteCollateral;
/**
 * Buys discounted collateral from the protocol. This collateral is available
 *     after an insolvent borrower account has been absorbed by the protocol.
 *     Collateral is only sold when the target reserves amount is not yet
 *     reached. The `mantissa` call option is applied to both the `minAmount`
 *     and `baseAmount` parameters.
 *
 * @param {string} asset A string of the name of the asset to buy.
 * @param {number | string | BigNumber} minAmount A string, number, or BigNumber
 *     object of the minimum amount of an asset to buy from the protocol. Use
 *     the `mantissa` boolean in the `options` parameter to indicate if this
 *     value is scaled up (so there are no decimals) or in its natural scale.
 * @param {number | string | BigNumber} baseAmount A string, number, or
 *     BigNumber object of the amount of base asset used to buy the collateral.
 * @param {string} recipient The desination account address of the collateral
 *     that is purchased.
 * @param {boolean} noApprove Explicitly prevent this method from attempting an
 *     ERC-20 `approve` transaction prior to buying collateral using the base
 *     asset.
 * @param {CallOptions} [options] Call options and Ethers.js overrides for the
 *     transaction.
 *
 * @returns {object} Returns an Ethers.js transaction object of the buy
 *     transaction.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function() {
 *
 *   const me = '0xRecipient';
 *
 *   console.log('Buying collateral...');
 *   const trx = await comet.buyCollateral(
 *     Compound.WBTC,
 *     1,
 *     10000
 *   );
 *   console.log('Ethers.js transaction object', trx);
 *   await trx.wait(1);
 *
 * })().catch(console.error);
 * ```
 */
function buyCollateral(asset, minAmount, baseAmount, recipient, noApprove, options) {
    if (noApprove === void 0) { noApprove = false; }
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var errorPrefix, provider, deployment, cometAddress, baseAssetAddress, assetAddress, userAddress, allowance, notEnough, parameters;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    errorPrefix = 'Compound Comet [buyCollateral] | ';
                    provider = this._provider;
                    deployment = this._cometDeploymentName;
                    cometAddress = address[deployment][constants_1.constants.Comet];
                    baseAssetAddress = address[deployment][getBaseAssetName(deployment)].contract;
                    try {
                        assetAddress = address[deployment][asset].contract;
                    }
                    catch (e) { }
                    if (!isValidEthereumAddress(assetAddress) ||
                        assetAddress === baseAssetAddress) {
                        throw Error(errorPrefix + 'Argument `asset` is not valid to buy.');
                    }
                    if (!isValidEthereumAddress(recipient)) {
                        throw Error(errorPrefix + 'Argument `recipient` is not valid.');
                    }
                    if (!options.mantissa) {
                        baseAmount = +baseAmount;
                        baseAmount = baseAmount * Math.pow(10, decimals[deployment][getBaseAssetName(deployment)]);
                        minAmount = +minAmount;
                        minAmount = minAmount * Math.pow(10, decimals[deployment][asset]);
                    }
                    baseAmount = ethers_1.ethers.BigNumber.from(baseAmount.toString());
                    minAmount = ethers_1.ethers.BigNumber.from(minAmount.toString());
                    options.abi = constants_1.abi.Erc20;
                    options._compoundProvider = provider;
                    if (!(noApprove !== true)) return [3 /*break*/, 6];
                    userAddress = provider.address;
                    if (!(!userAddress && provider.getAddress)) return [3 /*break*/, 3];
                    return [4 /*yield*/, provider.getAddress()];
                case 2:
                    userAddress = _a.sent();
                    _a.label = 3;
                case 3: return [4 /*yield*/, eth.read(baseAssetAddress, 'allowance', [userAddress, cometAddress], options)];
                case 4:
                    allowance = _a.sent();
                    notEnough = allowance.lt(baseAmount);
                    if (!notEnough) return [3 /*break*/, 6];
                    // ERC-20 approve transaction
                    return [4 /*yield*/, eth.trx(baseAssetAddress, 'approve', [cometAddress, baseAmount], options)];
                case 5:
                    // ERC-20 approve transaction
                    _a.sent();
                    _a.label = 6;
                case 6:
                    options.abi = constants_1.abi.Comet;
                    parameters = [assetAddress, minAmount, baseAmount, recipient];
                    return [2 /*return*/, eth.trx(cometAddress, 'buyCollateral', parameters, options)];
            }
        });
    });
}
exports.buyCollateral = buyCollateral;
/**
 * Gets the price of the asset that is passed to it in USD as an unsigned
 *     integer, scaled up by 10 ^ 8.
 *
 * @param {string} asset A string of the symbol of the asset.
 *
 * @returns {string} Returns the price of the asset that is passed to it in USD
 *     as an unsigned integer, scaled up by 10 ^ 8.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const price = await comet.getPrice(Compound.WBTC);
 *   console.log('Price of WBTC', price);
 * })().catch(console.error);
 * ```
 */
function getPrice(asset) {
    return __awaiter(this, void 0, void 0, function () {
        var deployment, cometAddress, errorPrefix, assetPriceFeedAddress, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    deployment = this._cometDeploymentName;
                    cometAddress = address[deployment][constants_1.constants.Comet];
                    errorPrefix = 'Compound Comet [getPrice] | ';
                    try {
                        assetPriceFeedAddress = address[deployment][asset].priceFeed;
                    }
                    catch (e) {
                        throw Error(errorPrefix + 'Argument `asset` price is not available.');
                    }
                    parameters = [assetPriceFeedAddress];
                    trxOptions = {
                        _compoundProvider: this._provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'getPrice', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result.toString()];
            }
        });
    });
}
exports.getPrice = getPrice;
/**
 * Gets the current borrow balance of an account as an unsigned integer. If the
 *     account has a non-negative base asset balance, it will return 0.
 *
 * @param {string} account The account address as a string.
 *
 * @returns {string} Returns the collateralization of the account as an integer.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const address = '0xAccountThatBorrows';
 *   const bal = await comet.borrowBalanceOf(address);
 *   console.log('Borrow Balance', bal.toString());
 * })().catch(console.error);
 * ```
 */
function borrowBalanceOf(account) {
    return __awaiter(this, void 0, void 0, function () {
        var cometAddress, errorPrefix, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    errorPrefix = 'Compound Comet [borrowBalanceOf] | ';
                    if (!isValidEthereumAddress(account)) {
                        throw Error(errorPrefix + 'Argument `account` is not a string or is an invalid address.');
                    }
                    parameters = [account];
                    trxOptions = {
                        _compoundProvider: this._provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'borrowBalanceOf', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result.toString()];
            }
        });
    });
}
exports.borrowBalanceOf = borrowBalanceOf;
/**
 * Gets the current balance of the collateral asset for the specified account.
 *
 * @param {string} account The account address as a string.
 * @param {string} asset The name of the collateral asset.
 *
 * @returns {string} Returns the collateral balance as an integer.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const address = '0xAccountThatSupplied';
 *   const balance = await comet.collateralBalanceOf(address, Compound.WBTC);
 *   console.log('Collateral balance', balance);
 * })().catch(console.error);
 * ```
 */
function collateralBalanceOf(account, asset) {
    return __awaiter(this, void 0, void 0, function () {
        var deployment, cometAddress, errorPrefix, assetAddress, parameters, trxOptions, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    deployment = this._cometDeploymentName;
                    cometAddress = address[deployment][constants_1.constants.Comet];
                    errorPrefix = 'Compound Comet [collateralBalanceOf] | ';
                    if (!isValidEthereumAddress(account)) {
                        throw Error(errorPrefix + 'Argument `account` is not a string or is an invalid address.');
                    }
                    try {
                        assetAddress = address[deployment][asset].contract;
                    }
                    catch (e) { }
                    if (!assetAddress || !collaterals[deployment].includes(asset)) {
                        throw Error(errorPrefix + 'Argument `asset` is not a valid collateral.');
                    }
                    parameters = [account, assetAddress];
                    trxOptions = {
                        _compoundProvider: this._provider.provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'collateralBalanceOf', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    return [2 /*return*/, result.toString()];
            }
        });
    });
}
exports.collateralBalanceOf = collateralBalanceOf;
/**
 * Gets the stored information for a supported asset.
 *
 * @param {number | string | BigNumber} assetIndex The index of the asset in the
 *     array in the Comet contract.
 *
 * @returns {AssetInfo} Returns a tuple of the asset's information.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const assetInfo = await comet.getAssetInfo(2);
 *   console.log('Asset Info', assetInfo);
 * })().catch(console.error);
 * ```
 */
function getAssetInfo(assetIndex) {
    return __awaiter(this, void 0, void 0, function () {
        var cometAddress, parameters, trxOptions, result, info;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    cometAddress = address[this._cometDeploymentName][constants_1.constants.Comet];
                    parameters = [assetIndex];
                    trxOptions = {
                        _compoundProvider: this._provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'getAssetInfo', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    info = {
                        offset: result.offset,
                        asset: result.asset,
                        priceFeed: result.priceFeed,
                        scale: result.scale,
                        borrowCollateralFactor: result.borrowCollateralFactor,
                        liquidateCollateralFactor: result.liquidateCollateralFactor,
                        liquidationFactor: result.liquidationFactor,
                        supplyCap: result.supplyCap
                    };
                    return [2 /*return*/, info];
            }
        });
    });
}
exports.getAssetInfo = getAssetInfo;
/**
 * Gets the stored information for a supported asset.
 *
 * @param {string} _address The contract address of the supported asset.
 *
 * @returns {AssetInfo} Returns a tuple of the asset's information.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const assetInfo = await comet.getAssetInfoByAddress('0xContract');
 *   console.log('Asset Info', assetInfo);
 * })().catch(console.error);
 * ```
 */
function getAssetInfoByAddress(_address) {
    return __awaiter(this, void 0, void 0, function () {
        var deployment, cometAddress, baseAssetAddress, errorPrefix, parameters, trxOptions, result, info;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    deployment = this._cometDeploymentName;
                    cometAddress = address[deployment][constants_1.constants.Comet];
                    baseAssetAddress = address[deployment][getBaseAssetName(deployment)].contract;
                    errorPrefix = 'Compound Comet [getAssetInfoByAddress] | ';
                    if (!isValidEthereumAddress(_address) ||
                        _address === baseAssetAddress) {
                        throw Error(errorPrefix + 'Argument `_address` is not valid.');
                    }
                    parameters = [_address];
                    trxOptions = {
                        _compoundProvider: this._provider,
                        abi: constants_1.abi.Comet
                    };
                    return [4 /*yield*/, eth.read(cometAddress, 'getAssetInfoByAddress', parameters, trxOptions)];
                case 2:
                    result = _a.sent();
                    info = {
                        offset: result.offset,
                        asset: result.asset,
                        priceFeed: result.priceFeed,
                        scale: result.scale,
                        borrowCollateralFactor: result.borrowCollateralFactor,
                        liquidateCollateralFactor: result.liquidateCollateralFactor,
                        liquidationFactor: result.liquidationFactor,
                        supplyCap: result.supplyCap
                    };
                    return [2 /*return*/, info];
            }
        });
    });
}
exports.getAssetInfoByAddress = getAssetInfoByAddress;
/**
 * Gets the stored information for a supported asset.
 *
 * @param {string} symbol The symbol of the supported asset.
 *
 * @returns {AssetInfo} Returns a tuple of the asset's information.
 *
 * @example
 *
 * ```
 * const compound = new Compound(window.ethereum);
 * const comet = compound.comet.MAINNET_USDC();
 *
 * (async function () {
 *   const assetInfo = await comet.getAssetInfoBySymbol(Compound.WETH);
 *   console.log('Asset Info', assetInfo);
 * })().catch(console.error);
 * ```
 */
function getAssetInfoBySymbol(asset) {
    return __awaiter(this, void 0, void 0, function () {
        var errorPrefix, assetAddress, result, info;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkValidCometProvider(this)];
                case 1:
                    _a.sent();
                    errorPrefix = 'Compound Comet [getAssetInfoBySymbol] | ';
                    try {
                        assetAddress = address[this._cometDeploymentName][asset].contract;
                    }
                    catch (e) { }
                    if (!assetAddress ||
                        asset === getBaseAssetName(this._cometDeploymentName) ||
                        !collaterals[this._cometDeploymentName].includes(asset)) {
                        throw Error(errorPrefix + 'Argument `asset` is not a valid collateral.');
                    }
                    return [4 /*yield*/, this.getAssetInfoByAddress(assetAddress)];
                case 2:
                    result = _a.sent();
                    info = {
                        offset: result.offset,
                        asset: result.asset,
                        priceFeed: result.priceFeed,
                        scale: result.scale,
                        borrowCollateralFactor: result.borrowCollateralFactor,
                        liquidateCollateralFactor: result.liquidateCollateralFactor,
                        liquidationFactor: result.liquidationFactor,
                        supplyCap: result.supplyCap
                    };
                    return [2 /*return*/, info];
            }
        });
    });
}
exports.getAssetInfoBySymbol = getAssetInfoBySymbol;
/**
 * Gets an array of the supported Compound III deployment names.
 *
 * @returns {string[]} Returns an array of strings that are used to refer to each Compound III deployment.
 *
 * @example
 *
 * ```
 * const networkNames = Compound.comet.getSupportedDeployments();
 * ```
 */
function getSupportedDeployments() {
    return Object.keys(address);
}
exports.getSupportedDeployments = getSupportedDeployments;
/**
 * Gets an array of the supported collateral assets in the specified Comet
 *     instance.
 *
 * @param {string?} deployment The specific deployment in which to get supported
 *     collaterals. The key is usually `${network}_${baseAssetSymbol}`. Use
 *     `getSupportedDeployments` to get proper values for this parameter.
 *     Defaults to cUSDCv3 on Ethereum Mainnet (`mainnet_usdc`) if nothing is
 *     passed.
 *
 * @returns {string[]} Returns an array of strings of the asset names.
 *
 * @example
 *
 * ```
 * const collaterals = Compound.comet.getSupportedCollaterals();
 * ```
 */
function getSupportedCollaterals(deployment) {
    if (!deployment) {
        deployment = 'mainnet_usdc';
    }
    if (!collaterals[deployment]) {
        throw Error('Argument `deployment` is not recognized.');
    }
    else {
        return collaterals[deployment];
    }
}
exports.getSupportedCollaterals = getSupportedCollaterals;
/**
 * Gets the name of the base asset in the specified instance.
 *
 * @param {string?} deployment The specific deployment in which to get supported
 *     collaterals. The key is usually `${network}_${baseAssetSymbol}`. Use
 *     `getSupportedDeployments` to get proper values for this parameter.
 *     Defaults to cUSDCv3 on Ethereum Mainnet (`mainnet_usdc`) if nothing is
 *     passed.
 *
 * @returns {string} Returns a string of the base asset name.
 *
 * @example
 *
 * ```
 * const baseAssetName = Compound.comet.getBaseAssetName();
 * ```
 */
function getBaseAssetName(deployment) {
    if (!deployment) {
        deployment = 'mainnet_usdc';
    }
    if (!base[deployment]) {
        throw Error('Argument `deployment` is not recognized.');
    }
    else {
        return base[deployment];
    }
}
exports.getBaseAssetName = getBaseAssetName;
//# sourceMappingURL=comet.js.map